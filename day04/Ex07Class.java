package day04;
/* 
 * 클래스 : 하나의 별개의 프로그램.
 * 객체지향프로그램에서는 프로그램이 기능을 불러다 쓰는 것이 아니라
 * 프로그램 통채로 가져다 쓰는 것을 목표로 한다.
 * 즉 커다란 프로그램이 작은 프로그램들을 불러서 쓰는데
 * 그 작은 프로그램을 커다란 프로그램에 등록할 때 변수를 선언하듯이 선언과
 * 초기화에서 사용하게 된다.
 * 
 * 작은 프로그램의 기능을 실행시키면 그 작은 프로그램이 내부적으로
 * 해당 기능을 실행시키고 그 결과값을 큰 프로그램에 보내주게 된다.
 * 
 * 예를 들어서 우리가 키보드 입력을 할 떄에는
 * 해당 기능을 담당하는 Scanner 클래스 타입의 변수를 만들어서
 * 걔가 알아서 하도록 우리가 기능만 호출해준다.
 * 
 * 그래고 이런 클래스 타입의 변수를 우리가 객체라고 부른다.
 * 즉 객체지향프로그래밍(Object Oriented Programming)이란
 * 그러한 작은 프로그램들을 다양하게 만들어서 우리가 필요할 때
 * 그 작은 프로그램 변수들만 가져다 쓰는게 객체지향프로그래밍이 지향하는 바이다.
 *
 * 클래스의 구성요소
 * 클래스는 필드와 메소드로 이루어져있다.
 * 필드 : 해당 클래스 변수가 가지고 있을 정보의 틀
 *       예시-> 학생의 경우 학번, 이름, 국어, 영어, 수학들의 점수들
 * 		 클래스에서 필드를 만들때에는 우리가 메소드안에 변수를 만들듯이
 *       "데이터타입 필드이름" 으로 선언해주면 된다
 * 
 * 메소드 : 해당 클래스의 변수들이 가지고 있을 기능을
 *        선언/구현해 놓은 것이다.
 *        메소드를 선언 할 떄에는
 *        리턴타입 이름(피라미터)로 선언한다.
 *        리턴타입 : 해당 기능이 종료될 떄 호출된 곳으로보내줄 데이터의 데이터타입.
 *        		   만약 해당 메소드가 아무런 값도 보내주지 않는다면 void라고
 *           	   적어주어야 한다. 또한 만약 리턴타입이 void가 아니라면
 *            	   해당 타입과 일치하는 데이터를 반드시 return 키워드와 합쳐서
 *            	   메소드 내부에 있어야 한다.
 *            
 *            	   반대로 리턴타입이 void이면 return키워드를 적으면 에러가 난다.
 *            	   또한 메소드 내부에서 return이 나오면 해당 메소드는 그 라인에서 종료가 된다. 
 *
 *
 *
 *		이름 : 소문자로 시작하는 동사
 *
 *		파라미터 : 파라미터란 해당 메소드를 실행시킬 때 필요로하는 외부의 값을 변수의 형태로
 *			 	 지정한 것이다.
 *				 외부에서 보내줄 때 뭐라고 보내주던 간에 해당 메서드 내부에서는
 *				 우리가 지정한 이름으로 호출된다.
 *
 *				 또한 파라미터는 필드와 이름이 같을 수 있는데 이 때에는 해당 이름을 쓰면
 *               파라미터가 호출된다.
 *               예시) 필드에서도 id가 있고 파라미터에도 id가 있으면 메소드 내부에서 id는
 *                    파라미터로 넘어온 id를 뜻한다.
 *                    이럴 때에는 필드를 지칭할 대 필드이름 앞에 this.을 붙여서 해당
 *                    이름은 필드라는 것을 명시해주면 된다.
 * 
 * 
 *   static : 자바에서 해당 필드 혹은 메소드를 객체 생성 없이 사용할 수 있도록 등록하는 키워드.
 *   		  단, 객체 생성을 하지 않는다는 것은 객체지향프로그래밍의 목표와는 정반대이므로,
 *   		  더이상 static 키워드를 우리가 만드는 메소드에 사용하는 것은 추천하지 않는다.
 *   
 *      	  또한 static 키워드가 붙은 메소드가 같은 클래스에 있는 필드나 메소드를 호출하려고 하면, 
 *       	  그 다른 필드나 메소드에도 static이 붙어야 한다. 
 *       
 *  생성자(Constructor)
 *  해당 클래스의 객체가 생성될 때 호출되는 메소드로써
 *  뭔가 초기화 작업이 필요할 경우, 생성자가 해주게 된다.
 *  우리가 따로 생성자를 만들어주지 않더라도 자바가 기본적으로 제공해주는 생성자가
 *  필드를 초기화 해 준다. 만약 필드의 데이터타입이 기본형일 경우 0으로 초기화해준다.
 *  만약 필드의 데이터타입이 참조형일 경우 null로 초기화해준다.
 *  
 *   생성자의 경우 우리가 직접 어떤 값으로 초기화할지 혹은 어떤 코드를 실행할 지 직접
 *   만들어줄 수 도 있는데 우리가 직접 생성자를 만들경우, 자바가 기본적으로 제공해주는 기본 생성자는
 *   더이상 호출할 수 없다.
 *   
 *   단, 크래스에 파라밈턱 있는 생성자만 만들어주게 된다면
 *   더이상 파라미터 없는 생성자 혹은 기본 생성자는 호출이 불가능해진다.
 *   
 *   메소드 오버로딩(overloading)
 *   메소드 오버로딩이란 파라미터를 다르게 해서 같은 목적을 가진 메소드들의
 *   이름을 통일시켜주는 방법을 메소드 오버로딩이라고 한다.
 *     
 *   예시 : System.out.println()의 다양한 파라미터들!
 *   
 *   1. (int id, String name, int korean, int english, int math)
 *   	(int id, String name)
 *   2. (int id, String name)
 *   	(String name, int id)
 *   3. (int korean, int english, int math)
 *      (int math, int korean, int english)
 *      
 *   1번과 파라미터가 다르다. 왜냐하면 갯수가 틀리기 떄문.
 *   (1, "조재영")이라고하면 어떤 메소드가 호출될지 결정된다.
 *   2번의 두개의 파라미터는 서로 다른 파라미터이다. 왜냐하면 순서가 틀리기 떄문.
 *   만약 ("조재영", 1)이라고 하면 명확하게 어떤 메소드가 호출될지 결정된다.
 *   
 *   3번의 두개의 파라미터는 서로 같은 파라미터이며 (80,80,81)이라고 하면 
 *   어떤 메소드가 호출될 지 애매모호하기 떄문.
 *   
 *   파라미터가 같은지 다른지를 볼 때에는 
 *   파라미터의 이름은 무시하고 데이터 타입의 순서가
 *   같은지를 비교하면 된다.
 * 
 * 	 상속
 *   프래그래밍에서 상속은 부ㅗ클래스의 메소드를 자식클래스가 다시 선언/구현을
 *   하지 않아도 그대로 사용할 수 있게 코드와 재사용성을 높여주는 방법이다.
 *   우리가 비록 Student 클래스 혹은 다른 클래스에 상속 명령어를 적지 않아도
 *   자바가 몰래 java.lang.Object를 상속한다.
 *   
 *   그래서 우리가 몇몇 메소드(toString(), equals()등)들은 따로 구현을
 *   하지 않아도 실행할 수 있다.
 *   
 *   하지만 java.lang.Object 는 우리 클래스에 어떤 필다가 있는지 혹은
 *   어떤 값을중심으로 같은지 다른지 비교를 할 지를 모르기 때문에
 *   java.lang.Object의 메소드들은 전부 매우 애매모호하게 구현되어있다.
 *   따라서 우리 클래스의 객체가 해당 메소드들을 제대로 사용하려면 우리가 직접 재정의해주어야 한다.
 *   
 *   이렇게 부모 클래스로부터 상속받은 메소들을 자식 클래스가 재정의하는 것을
 *   오버라이딩(overriding)이라고 한다.
 *   오버라이딩 할 떄 주의해야할 점은 부모클래스가 메소드를 선언한 방법 그대로를 선언해주어야 한단 것이다.
 *   
 *   //1. toString()
 *        해당 객체의 정보를 String으로 바꿔준다.
 *        System.out.println()의 경우, 파라미터로 Object 클래스 혹은
 *        Object 클래스를 상속받는 모든 클래스 객체가 파라미터로 들어오면 행당 객체의
 *        toString() 결과값을 화면에 출력해준다.
 *        java.lnag.Object클래스는 toString()에 해당 클래스의 정보
 *        (패키지 + 클래스이름)와 해당 객체의 메모리 주소값을 String으로 바꿔서 return 해준다.
 *        만약 우리가 만든 클래스의 객체를 System.out.println()에 넣어서 현재 해당 객체의
 *        필드값을 출력하게 만들려며 우리가 직접 toString()을 재 정의 해야한다.
 *        toString()은 다음과 같이 선언되어 있다.
 *        public String toString()
 *        
 *        
 *     2. equals()
 *     	  비교연산자 == 의 경우, 객체끼리 비교하면 
 *        주소값 비교를 하기 떄문에, 개게의 필드값 비교를 위해서는
 *        equals()를 통해서 비교해야한다.
 *        이 equals() 메소드도 java.lang.Object에 정의되어있다.
 *        근데 toString()과 마찬가지로 java.lang.Object는 해당 클래스의
 *        어떤 필드를 기준으로 비교를 할지 알까?
 *        당연히 모른다. 그래서 충격적이게도 java.lang.Object의 equals()는
 *        다음과 같이 생겼다.
 *        public boolean equals(Object o){
 *               return this == o;
 *        }
 *        즉 주소값 비교를 하게 되는 것이다.
 *        따라서 우리 클래스 객체의 필드를 기준으로 해서 비교를 할려면
 *        toString()과 마찬가지로 우리가 오버라이드를 해야한다.
 * 
 * 		  null
 *        null이란 창조형 변수/상수에서만 발견되는 특수한 상황이다.
 *        정상적으로 초기화된 참조형 변수/상수는
 *    	  변수/상수 자체는 주소값을 가지고 있고 그 주소값을 찾아서 들어가면 실제 해당 데잍타입의 값들이
 *        존재하는 형태가 된다. 
 *        
 *        그런데 만약, 그 주소값을 찾아서 들어간 곳에, 아무런 정보가 없다면?
 *        그 참조형 변수/상수의 필드 혹은 메소드 등 상세한 정보를 전혀 알 수 없게 된다.
 *        이렇게 해당 메모리 주소에 아무것도 없는 상태를 null이라고,
 *        null인 참조형 변수/상수의 필드 혹은 메소드를 호출하면
 *        NullPointerException 이라는 에러가 발생하게 된다!!!
 * 
 * 	      다형성(polymorphism)
 * 		  다형성이란 다양한 모습을 가지는 성격이라고 할수 있다.
 *        자바에서는 부모클래스가 파라미터로 적히는 경우
 *  	  자식 클래스도 파라미터로 들어올 수 있다.
 * 
 * 		  접근제한자(Access Modifier)
 * 		  접근 제한자란 해당 필드 혹은 메소드의 접근 범위를 결정하는 키워드이다.
 *        public > protected > default > private 순의 범위이다.
 *        public : 내부 패키지의 외부 클래스나 외부 패키지의 외부 클래스나
 *        		   어디서든 접근 가능(객체를 만들어서 해당 필드 혹은 메소드를 호출가능)
 *        
 *        protected: 내부 패키지의 다른 클래스면 접근 가능하지만
 *        			 외부 패키지에서는 해당 클래스를 상속받는 클래스만 접근 가능.
 *        			 
 *        default; 내부 패키지의 다른 클래스면 접근 가능하지만
 *         	       외부 패키지의 모든 클래스는 접근 안됨.
 *         		   이렇기 떄문에 패키지 접근 제한자라고 불리지만
 *         	       default와 package 모두 다른 곳에서 쓰이는 키워드기 떄문에
 *         		   우리가 아무런 접근 제한자를 메소드나 필드에 붙이지 않으면
 *        		   자동으로 default 접근 제한자가 적용된다.
 *        private : 외부 클래스면 모두 접근이 불가능. 해당 클래스에서만 볼 수 있음.
 *           	    예전에는 정말 외부에 알려주기 싫은 메소드 혹은 필드만 private으로 해두고
 *                  나머지는 전부 public으로 두어도 괜찮았다.
 *                  하지만 이제는 캡슐화라는 개념 떄문에 외부가 꼭 알아야할 메소드를 제외하고서는
 *                  모든 필드 ->private
 *                  거의 모든 메소드 ->private
 *                  외부가 꼭 필요로 하는 메소드만 -> public
 *                  으로 접근 제한을 하게 된다.
 *                  
 *                  캡슐화란 객체를 만들면 굳이 그객체의 내용을 다른 외부가 알 필요없고
 *                  그 객체 자체를 쓰면 된다는 관점에서 존재하는 것이다.
 *                  
 *                  하지만 필드의 경우 private 접근 제한자가 적용되면 외부에 값을 직접 넘겨주거나
 *                  호출하는 것이 불가능해진다.
 *                  
 *                  그래서 이제는 메소드를 통해서 간접적으로 필드에 값을 저장하고 저장된 값을
 *                  리턴하는 방법을 쓰게 된다.
 *                  
 *                  외부로부터 값을 받아서 필드에 값을 할당하는 메소드를 setter 메소드라고 한다.
 *                  setter 메소드는 다음과 같은 "양식"을 가진다.
 *                  public void set필드이름(필드타입 필드이름){
 *                        this.필드이름 = 필드이름;
 *                  }
 *                  만약 값을 저장할 때, 추가적으로 작업할 것이 있다면, setter 메소드 내부에 구현하면 된다.
 *                  
 *                  필드에 저장된 값을 호출된 곳으로 리턴하는 메소드는 getter 메소드라고 한다.
 *                  getter 메소드는 다음과 같은 "양식"을 가진다.
 *                  public 필드타입, get필드이름(){
 *                  		return 필드이름;
 *                  }
 *                  만약 값을 리턴할 때 추가적으로 작업할 것이 있따면 getter 메소드 내부에 구현하면 된다.

 *        
 * */

public class Ex07Class {

}
